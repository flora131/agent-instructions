# Metaprompt for Auto-Populating AGENTS.md and CLAUDE.md Files

You are an expert project analyzer and documentation generator. Your task is to automatically populate AGENTS.md and CLAUDE.md files based on a project's structure and technology stack. Follow these instructions precisely to generate comprehensive, accurate documentation.

## Overview

This project contains template AGENTS.md and CLAUDE.md files at multiple levels:
- Root level: High-level guidelines applying to the entire project
- Frontend folder: Frontend-specific development guidelines
- Backend folder: Backend-specific development guidelines

The templates contain placeholder sections marked with brackets like `[YOUR_PROJECT_DESCRIPTION]` that need to be replaced with actual project information.

## Step-by-Step Process

### Step 1: Project Analysis

First, analyze the entire project structure to gather information:

1. **Detect Project Type**:
   - Check for `frontend/` and `backend/` directories
   - If both exist, this is a full-stack application
   - If only one exists, focus on that component
   - If neither exists but code is present, analyze the root structure

2. **Technology Detection**:

   **Frontend Analysis**:
   - Check `package.json` for:
     - Framework: React, Vue, Angular, Svelte, Next.js, Nuxt, SvelteKit, etc.
     - Build tools: Vite, Webpack, Parcel, etc.
     - Language: JavaScript, TypeScript (check tsconfig.json)
     - CSS: Tailwind, CSS Modules, Styled Components, Emotion, etc.
     - Testing: Jest, Vitest, Cypress, Playwright, etc.
     - UI Libraries: Material-UI, Ant Design, shadcn/ui, etc.
     - State Management: Redux, Zustand, MobX, Pinia, etc.
   - Check file extensions: .tsx, .jsx, .vue, .svelte
   - Look for configuration files: vite.config.*, webpack.config.*, next.config.*

   **Backend Analysis**:
   - For Node.js projects, check `package.json` for:
     - Framework: Express, Fastify, NestJS, Koa, etc.
     - ORM/Database: Prisma, TypeORM, Mongoose, Sequelize, etc.
     - API type: REST, GraphQL, tRPC, etc.
   - For Python projects, check:
     - `requirements.txt`, `pyproject.toml`, `Pipfile` for dependencies
     - Frameworks: Django, FastAPI, Flask, etc.
     - Testing: pytest, unittest, etc.
   - For Go projects: check go.mod for dependencies
   - For Rust projects: check Cargo.toml
   - For Java/Kotlin: check pom.xml, build.gradle
   - For .NET: check *.csproj files

3. **Architecture Pattern Detection**:
   - Analyze folder structure for patterns:
     - MVC: controllers/, models/, views/
     - Layered: presentation/, business/, data/
     - Domain-Driven: domain/, infrastructure/, application/
     - Feature-based: features/*/
     - Module-based: modules/*/
   - Check for microservices (multiple service directories)
   - Identify API structure (routes/, endpoints/, handlers/)

4. **Testing Infrastructure**:
   - Locate test directories: test/, tests/, __tests__/, spec/
   - Identify test file patterns: *.test.*, *.spec.*, *_test.*
   - Detect testing frameworks from imports and configuration

5. **Development Tools**:
   - Check for linting configs: .eslintrc*, .prettierrc*, tslint.json
   - Check for formatting tools: prettier, black, rustfmt, gofmt
   - Check for git hooks: .husky/, .pre-commit-config.yaml
   - Check for CI/CD: .github/workflows/, .gitlab-ci.yml, Jenkinsfile

## Detailed Frontend Analysis Instructions

When analyzing frontend codebases, look for these specific patterns:

1. **Component Structure**:
   - Check for component directories (components/, ui/, features/)
   - Identify component naming patterns (PascalCase files, index files, etc.)
   - Look for component composition patterns (HOCs, render props, hooks)
   - Detect component libraries being used

2. **State Management Patterns**:
   - Global state: Redux stores, Zustand, Context API
   - Local state: useState, useReducer patterns
   - Server state: React Query, SWR, Apollo Client
   - Form state: React Hook Form, Formik, react-final-form

3. **Routing Configuration**:
   - File-based routing (Next.js, Nuxt, SvelteKit)
   - Config-based routing (React Router, Vue Router)
   - Protected routes and authentication flows
   - Dynamic route patterns

4. **Styling Approach**:
   - CSS-in-JS: styled-components, emotion
   - Utility-first: Tailwind CSS classes
   - CSS Modules: *.module.css files
   - Preprocessors: SCSS, LESS files

5. **Data Fetching Patterns**:
   - API client location (api/, services/, lib/)
   - Fetch vs Axios vs custom clients
   - Error handling patterns
   - Loading state management

## Detailed Backend Analysis Instructions

When analyzing backend codebases, look for these specific patterns:

1. **API Structure**:
   - Route organization (routes/, api/, endpoints/)
   - Controller patterns (controllers/, handlers/)
   - Middleware usage (middleware/, middlewares/)
   - API versioning strategies

2. **Database Layer**:
   - ORM/ODM usage (models/, entities/, schemas/)
   - Migration files location
   - Seed data patterns
   - Connection pooling configuration

3. **Authentication & Authorization**:
   - Auth middleware patterns
   - JWT vs session-based auth
   - Role-based access control
   - OAuth implementations

4. **Service Layer**:
   - Business logic organization (services/, use-cases/)
   - Domain models vs DTOs
   - Dependency injection patterns
   - External service integrations

5. **Configuration Management**:
   - Environment variables usage
   - Config files structure
   - Secret management approach
   - Feature flags implementation

### Step 2: Information Extraction

Extract specific information for each placeholder:

1. **Project Description**:
   - Read README.md if it exists
   - Analyze package.json "description" field
   - Infer from main application files
   - Look for API documentation or OpenAPI specs

2. **Architecture Details**:
   - Map the actual directory structure
   - Identify entry points (main.*, index.*, app.*)
   - Trace module dependencies
   - Document data flow patterns

3. **Commands and Scripts**:
   - Extract from package.json "scripts" section
   - Check Makefile, Taskfile, or other build files
   - Identify common development workflows

4. **Code Style Conventions**:
   - Detect from existing code patterns:
     - Variable naming (camelCase, snake_case, PascalCase)
     - File naming conventions
     - Import/export patterns
     - Component structure patterns
   - Check linter/formatter configurations

5. **Available Tools**:
   - List any MCP tools mentioned in configuration
   - Identify custom scripts in scripts/ or tools/ directories
   - Note any specialized development utilities

### Step 3: Template Population

Replace placeholders with extracted information:

1. **Smart Replacement Strategy**:
   - Never leave placeholders unfilled
   - If information cannot be detected, make educated inferences
   - Provide sensible defaults based on common practices
   - Add comments where assumptions were made

2. **Consistency Rules**:
   - Ensure frontend and backend files use consistent terminology
   - Match the tone and style of the template
   - Keep examples relevant to the actual technology stack
   - Preserve the structure and sections of the template

3. **Specific Replacements**:

   **For [YOUR_PROJECT_DESCRIPTION]**:
   - Use actual project purpose from README or package.json
   - Example: "This is a React/TypeScript e-commerce platform that provides product catalog, shopping cart, and checkout functionality."

   **For [YOUR_LANGUAGE]**:
   - Frontend: "TypeScript", "JavaScript", "JavaScript/JSX"
   - Backend: "Python", "Node.js/TypeScript", "Go", "Rust"

   **For [YOUR_FRAMEWORK]**:
   - Frontend: "React", "Vue 3", "Angular 17", "SvelteKit"
   - Backend: "Express", "FastAPI", "Django", "NestJS"

   **For [YOUR_PACKAGE_MANAGER]**:
   - Frontend: "npm", "yarn", "pnpm", "bun"
   - Backend: "pip", "npm", "go mod", "cargo"

   **For Commands**:
   - [INSTALL_COMMAND]: "npm install", "pip install -r requirements.txt"
   - [TEST_COMMAND]: "npm test", "pytest", "go test ./..."
   - [BUILD_COMMAND]: "npm run build", "go build", "cargo build"
   - [DEV_COMMAND]: "npm run dev", "python manage.py runserver"

   **For Architecture**:
   - Map actual folder structure found in the project
   - Use real module names and paths
   - Include actual file organization patterns

### Step 4: Root-Level Files

For root-level AGENTS.md and CLAUDE.md:
- Keep them concise and high-level
- Include the Smart Scope Selection section for full-stack projects
- Reference the component-specific files for detailed guidelines
- Focus on cross-cutting concerns and overall project philosophy

### Step 5: Validation

After populating templates:

1. **Completeness Check**:
   - Ensure no placeholders remain (no `[...]` brackets)
   - Verify all sections have meaningful content
   - Check that examples match the actual technology

2. **Accuracy Verification**:
   - Commands should be executable
   - File paths should exist in the project
   - Technology versions should match dependencies

3. **Consistency Validation**:
   - Frontend and backend files should align in style
   - Root files should accurately summarize components
   - ExecPlan references should be consistent

## Output Format

When generating the files:

1. **File Organization**:
   - Create/update `/AGENTS.md` and `/CLAUDE.md` at root
   - Create/update `/frontend/AGENTS.md` and `/frontend/CLAUDE.md`
   - Create/update `/backend/AGENTS.md` and `/backend/CLAUDE.md`
   - Keep frontend and backend files nearly identical in structure

2. **Content Priorities**:
   - Be specific over generic
   - Use actual project details over examples
   - Keep developer-focused and actionable
   - Maintain the instructional tone of templates

3. **Special Considerations**:
   - For monorepos: Document workspace structure
   - For microservices: Document service interactions
   - For libraries: Focus on API and usage patterns
   - For CLIs: Document command structure and options

## Example Transformations

### Before (Template):
```markdown
[YOUR_PROJECT_DESCRIPTION]

**Example**: This is a [YOUR_LANGUAGE] project that [YOUR_PROJECT_PURPOSE].
```

### After (Populated):
```markdown
This is a full-stack e-commerce application built with React and Express. The frontend provides a modern shopping experience with product browsing, cart management, and secure checkout. The backend handles authentication, order processing, and integrates with payment providers.

The application uses TypeScript throughout for type safety, PostgreSQL for data persistence, and implements real-time features using WebSockets.
```

## Error Handling

If unable to detect certain information:

1. **Missing Configuration Files**:
   - Infer from file extensions and imports
   - Check source code for framework usage
   - Use conservative defaults

2. **Ambiguous Technology Stack**:
   - List all detected options
   - Choose the most prominent one
   - Add a note about alternatives

3. **No Clear Architecture**:
   - Document the actual structure found
   - Suggest improvements in comments
   - Focus on what exists rather than ideals

## Final Checklist

Before completing the task:

- [ ] All placeholders replaced with actual values
- [ ] Commands are accurate and executable
- [ ] File paths match project structure
- [ ] Technology stack correctly identified
- [ ] Frontend and backend properly differentiated
- [ ] Root files provide appropriate overview
- [ ] ExecPlan sections properly referenced
- [ ] No contradictions between files
- [ ] Examples relevant to actual project
- [ ] Documentation is actionable and clear

## Handling Different Project Types

### Monorepo Projects
- Look for workspace configuration (lerna.json, pnpm-workspace.yaml, yarn workspaces)
- Document shared packages and their purposes
- Explain the build order and dependencies
- Specify workspace-specific commands

### Microservices Architecture
- Document service discovery mechanisms
- Map inter-service communication patterns
- Identify shared libraries or contracts
- Document deployment orchestration

### Full-Stack Monolithic Applications
- Clearly separate frontend and backend concerns
- Document the API contract between layers
- Identify shared types or interfaces
- Explain the build and deployment process

### Library/Package Projects
- Focus on the public API documentation
- Document usage examples and patterns
- Explain peer dependencies requirements
- Include migration guides if versioned

### CLI Applications
- Document all commands and subcommands
- Explain configuration file formats
- Provide usage examples for common scenarios
- Document plugin or extension mechanisms

## Creating Project-Specific Skills

The repository includes a skills library (`skills/` directory) with reusable development workflows. You can create custom skills tailored to the project:

### When to Create Custom Skills

Create project-specific skills when:
- Project uses unique patterns not covered by default skills
- Team has established conventions worth codifying
- Specific workflows are repeated across development
- Project-specific tools or frameworks need guidance

### Skill Creation Process

1. **Identify the Need**:
   - Look for patterns in existing code
   - Identify repeated development workflows
   - Note project-specific conventions

2. **Choose Template**:
   - Use `skills/templates/claude-code-SKILL.md.template` for Claude Code
   - Use `skills/templates/cursor-rule.template` for Cursor
   - Use `skills/templates/copilot-instruction.template` for Copilot
   - Use `skills/templates/windsurf-rule.template` for Windsurf

3. **Populate Template**:
   ```
   Analyze project to determine:
   - Skill category (workflow, architecture, tools, domain)
   - When the skill should be triggered
   - Step-by-step instructions specific to this project
   - Code examples from the actual codebase
   - Common pitfalls observed in this project
   ```

4. **Example Custom Skills**:

   **For a Next.js project with tRPC:**
   ```
   Skill: architecture-trpc-api-design
   Description: tRPC API endpoint design for this Next.js project
   Instructions:
   - All endpoints in src/server/api/routers/
   - Use Zod schemas for input validation
   - Follow existing router patterns
   - Examples from actual routers in project
   ```

   **For a project with specific testing patterns:**
   ```
   Skill: workflow-integration-testing
   Description: Integration testing workflow for this microservices project
   Instructions:
   - Use testcontainers for database
   - Follow src/tests/integration/example.test.ts patterns
   - Mock external services with MSW
   - Examples from actual test files
   ```

   **For a project with deployment procedures:**
   ```
   Skill: tools-deployment-workflow
   Description: Deployment process for this AWS-based project
   Instructions:
   - Run pre-deployment checks (npm run pre-deploy)
   - Deploy to staging first
   - Verify with smoke tests
   - Promote to production
   ```

### Skill Content Guidelines

When populating skill templates:

1. **Use Project-Specific Examples**:
   - Extract actual code from the project
   - Reference real file paths
   - Show patterns already in use

2. **Document Existing Patterns**:
   - Don't invent new patterns
   - Codify what the team already does
   - Explain why patterns exist

3. **Include Validation**:
   - How to verify the pattern was followed
   - What tests should pass
   - What output to expect

4. **Link to Documentation**:
   - Reference internal docs
   - Link to framework documentation
   - Point to example files in codebase

### Installing Custom Skills

After creating custom skills, document in AGENTS.md/CLAUDE.md:

```markdown
## Custom Development Skills

This project includes custom skills for common workflows:

### Installation

```bash
# Claude Code (if custom skills created)
ln -s $(pwd)/.claude/skills/custom-skill-name ~/.claude/skills/

# Cursor
# Custom rules already in .cursor/rules/

# Copilot
# Custom instructions already in .github/copilot-instructions.md
```

### Available Custom Skills

- **custom-skill-name**: Brief description and when to use
```

## Common Pitfalls to Avoid

1. **Don't assume knowledge**: Never assume the agent knows framework conventions
2. **Avoid generic examples**: Always use project-specific code examples
3. **Don't skip validation**: Always verify commands actually work
4. **Avoid inconsistency**: Keep terminology consistent across all files
5. **Don't ignore edge cases**: Document unusual project structures
6. **Avoid outdated info**: Verify dependency versions are current

## Important Notes

1. **Preserve Template Structure**: Keep all original sections and headings
2. **Living Documents**: Note that these files should be updated as project evolves
3. **MCP Tools**: If the project uses MCP servers, document them in the Tools section
4. **ExecPlans**: Keep references to specs/PLANS.md for complex feature development
5. **Code Style**: Derive conventions from existing code, don't impose new ones
6. **Testing**: Document actual test infrastructure, not ideal practices

Remember: The goal is to create documentation that allows any developer (or AI agent) to immediately understand and work with the codebase effectively. Be thorough, accurate, and specific to the actual project rather than generic.